const TZ = "America/Chicago";

// Building hours (local, 24h)
const BUILDING_OPEN_HOUR = 6;   // 6:00
const BUILDING_CLOSE_HOUR = 22; // 22:00

// Room order (top -> bottom)
const ROOMS_ORDER = ["1A","1B","2A","2B","3","4","5","6","7","8","9A","9B","10A","10B"];

// ----- utilities -----
const fmtDate = new Intl.DateTimeFormat("en-US", {
  timeZone: TZ, weekday: "long", month: "short", day: "numeric"
});

const fmtTime = new Intl.DateTimeFormat("en-US", {
  timeZone: TZ, hour: "numeric", minute: "2-digit"
});

function todayParts() {
  const now = new Date();
  const p = new Intl.DateTimeFormat("en-US", {
    timeZone: TZ, year: "numeric", month: "2-digit", day: "2-digit"
  }).formatToParts(now).reduce((acc, x) => (acc[x.type] = x.value, acc), {});
  return { y: +p.year, m: +p.month, d: +p.day };
}

function startOfDay() {
  const { y, m, d } = todayParts();
  return new Date(`${y}-${String(m).padStart(2,"0")}-${String(d).padStart(2,"0")}T00:00:00`);
}

function hourToMs(h){ return h * 60 * 60 * 1000; }

function clipToBuildingHours(startISO, endISO){
  const day0 = startOfDay().getTime();
  const open = day0 + hourToMs(BUILDING_OPEN_HOUR);
  const close = day0 + hourToMs(BUILDING_CLOSE_HOUR);
  const s = Math.max(new Date(startISO).getTime(), open);
  const e = Math.min(new Date(endISO).getTime(), close);
  return e > s ? [s, e] : null;
}

function hoursArray(){
  const arr = [];
  for(let h = BUILDING_OPEN_HOUR; h <= BUILDING_CLOSE_HOUR; h++){
    arr.push(h);
  }
  return arr;
}

// Compute left/width (%) of event within the time scale
function positionPct(startMs, endMs){
  const day0 = startOfDay().getTime();
  const rangeStart = day0 + hourToMs(BUILDING_OPEN_HOUR);
  const rangeEnd   = day0 + hourToMs(BUILDING_CLOSE_HOUR);
  const total = rangeEnd - rangeStart;
  const left = ((startMs - rangeStart) / total) * 100;
  const width = ((endMs - startMs) / total) * 100;
  return [Math.max(0,left), Math.max(0,width)];
}

// ----- live clock & date -----
function tickClock(){
  const now = new Date();
  const dateEl = document.getElementById("today-text");
  const clockEl = document.getElementById("clock");
  dateEl.textContent = fmtDate.format(now);
  clockEl.textContent = new Intl.DateTimeFormat("en-US", {
    timeZone: TZ, hour: "numeric", minute: "2-digit", second: "2-digit"
  }).format(now);
}
setInterval(tickClock, 1000);
tickClock();

// ----- tabs (visual only; keeps your current “tabbed look”) -----
const tabs = document.querySelectorAll(".tab");
tabs.forEach(t => {
  t.addEventListener("click", () => {
    tabs.forEach(x => x.classList.remove("active"));
    t.classList.add("active");
    const which = t.dataset.tab;
    document.getElementById("grid").classList.toggle("hidden", which !== "gym");
    document.getElementById("grid-fieldhouse").classList.toggle("hidden", which !== "fieldhouse");
  });
});

// ----- renderer -----
async function loadEvents(){
  // fetch events.json generated by scripts/transform.mjs
  try{
    const res = await fetch("./events.json", { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    return Array.isArray(data.events) ? data.events : [];
  }catch(e){
    console.warn("No events.json yet (rendering blank grid).", e);
    return [];
  }
}

function buildTimeHeader(root, hours){
  const ghours = hours.length - 1; // ticks between hours
  root.style.setProperty("--hours", String(hours.length));
  root.style.setProperty("--cols", `repeat(${hours.length}, minmax(80px, 1fr))`);

  const header = document.createElement("div");
  header.className = "time-header";

  const roomsCol = document.createElement("div");
  roomsCol.className = "rooms-col";
  roomsCol.textContent = "Rooms";
  header.appendChild(roomsCol);

  const scale = document.createElement("div");
  scale.className = "time-scale";
  hours.forEach((h) => {
    const tick = document.createElement("div");
    tick.className = "tick";
    const label = new Date(startOfDay().getTime() + hourToMs(h));
    tick.textContent = new Intl.DateTimeFormat("en-US", {
      timeZone: TZ, hour: "numeric"
    }).format(label);
    scale.appendChild(tick);
  });
  header.appendChild(scale);
  root.appendChild(header);
}

function buildRows(root, events){
  const rows = document.createElement("div");
  rows.className = "rows";
  rows.style.setProperty("--cols", getComputedStyle(root).getPropertyValue("--cols"));

  ROOMS_ORDER.forEach(room => {
    // left: room label
    const label = document.createElement("div");
    label.className = "room";
    label.textContent = room;
    rows.appendChild(label);

    // right: event layer
    const layer = document.createElement("div");
    layer.className = "row-events";

    // events for this room
    const mine = events.filter(e => e.room === room);
    mine.forEach(ev => {
      const clipped = clipToBuildingHours(ev.start, ev.end);
      if (!clipped) return;
      const [s, e] = clipped;
      const [leftPct, widthPct] = positionPct(s, e);

      const block = document.createElement("div");
      block.className = "event";
      block.style.left = `${leftPct}%`;
      block.style.width = `${widthPct}%`;

      const who = document.createElement("span");
      who.className = "who";
      who.textContent = ev.who || ev.purpose || "Reserved";

      const time = document.createElement("span");
      time.className = "time";
      time.textContent = `• ${fmtTime.format(new Date(s))}–${fmtTime.format(new Date(e))}`;

      block.appendChild(who);
      block.appendChild(time);
      layer.appendChild(block);
    });

    rows.appendChild(layer);
  });

  root.appendChild(rows);
}

async function render(){
  const gridGym = document.getElementById("grid");
  const gridField = document.getElementById("grid-fieldhouse");

  // Clear
  gridGym.innerHTML = "";
  gridField.innerHTML = "";

  const events = await loadEvents();

  // Filter: only rooms we know (1A..10B). Everything else is ignored (blank grid).
  const known = events.filter(e => ROOMS_ORDER.includes(e.room));

  const hours = hoursArray();
  buildTimeHeader(gridGym, hours);
  buildRows(gridGym, known);

  // Fieldhouse tab: show a blank grid with same hours & rows if you want symmetry
  buildTimeHeader(gridField, hours);
  buildRows(gridField, []); // intentionally blank — no placeholders
}

render();

// Optional: refresh the UI every 60s so the clock & any new events.json changes are reflected.
setInterval(render, 60_000);
